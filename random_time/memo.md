# C++の時間や乱数生成に関する知識

* PseudoRandomGenerator.cpp : C++98だけの機能で`rand()`相当な乱数生成クラスを実装したもの。
* highly_accurate_time_info.cpp : C++98＋OSのAPIでミリ秒、ナノ秒を取得するコード。
* rand_practice.cpp : std:rand() の練習コード。
* shuffle_practice.cpp : std::shuffle() 

## C++98 だけでは現在時刻の高精度な時間情報（ms, μs, ns）を取得するAPIはない。

### `<ctime>` ヘッダ `<time.h>`

* `std::time()` : エポック(1970年1月1日00:00:00 UTC)からの秒数を表示する。`time_t` 型
> ミリ秒以下の精度はない。

* `std::clock()` : プログラム起動時からのCPU時間（プロセッサ時間）を取得する。`clock_t` 型
> CPUサイクルやそのシステムでの「ティック」数に基づき、秒以下の精度は保証されない。

### 高精度な時間情報を取得するには

C++98 の標準機能だけでは不可能だが、OS固有のAPIを利用すると可能。

POSIX標準の `gettimeofday`, `clock_gettime` を使う。
> highly_accurate_time_info.cpp

@note
C++11 では `<chrono>` ヘッダが導入されて、プラットフォーム非依存で高精度な時間計測が可能となった。

***

## 乱数生成について

### 従来からの `std::rand()` は非推奨

`std::rand()`, `std::random_shuffle()` : 線形合同法のアルゴリズムなので、統計的に偏りがあったり、`RAND_MAX`(通常は`32767`)が小さかったりで、乱数の質は低いです。

ヘッダー : `<cstdlib>`を宣言すると使える。

### C++11 以降の高品質な乱数生成

* 乱数エンジン`std::shuffle()`

> `std::shuffle()`は、コンテナ（）内の要素をランダムな順序に並べ替えるためのアルゴリズムです。
>
> C++98までは乱数を直接生成する`std::rand()`を使われていたのに対して、C++11では乱数エンジン（`std::mt19937`など）と分布（`std::uniform_int_distribution`など）を組み合わせた高品質な擬似乱数生成器を使用することを前提としているものです。

### まとめ

| 特徴 | std::rand() | std::shuffle() |
| :---: | :---: | :---: |
| 目的 | 単一の擬似乱数を生成する | コンテナ内の要素をランダムに並べ替える（シャッフル） |
| 対象 | 整数値 | イテレータで指定された要素の範囲 |
| 乱数の質 | 低い（非推奨） | 高品質な乱数エンジンと組み合わせて使用（推奨） |
| 依存関係 | std::srand()でシードが必要 | 高品質な乱数エンジン（例: std::mt19937）が必要 |
| ヘッダ | <cstdlib> | <algorithm>, <random> |

***

### その他

* コードの解説
```c++
std::mt19937 rng(std::chrono::system_clock::now().time_since_epoch().count());
std::suffle(numbers.begin(), numbers.end(), rng);
```
> `std::mt19937 rng(...)`: メルセンヌ・ツイスター法に基づく乱数生成のアルゴリズム
>
> 19937は乱数の周期（2^19937-1）から来ている。
>
> 623次元で一様分布する。624個の連続した過去の出力履歴から次に出現する値を予測できる。

* [2038年問題](https://ja.wikipedia.org/wiki/2038%E5%B9%B4%E5%95%8F%E9%A1%8C)：WikiPedia

> 背景として、コンピューターの時刻を表現する「UNIX時間」という、`1970.01.01.00:00:00`からの経過時刻を表すシステムがある。これは、`time_t` 型で表ており、ほとんどのシステムが32ビット整数型で実装されているため、2038年1月19日3時14分7秒(`03:14:07 UTC on 19 January 2038`)に値がオーバーフローして、この値を正しく扱えていることを前提としたコードが誤作動する。
>
> 対策：`time_t`型を64ビット整数型（`long long`型）にすることで、西暦3000億年まで使用できる。事実上問題が発生しない。64ビット化できない環境については、`time_t`型を符号なし32ビット整数型に変更することで回避できる。
>
> 各コンピューターでは様々な対策が取られている。`macOS`(`Mac OS X 10.0`)だと`NSData`クラスにて世界協定時の2001.01.01 0:00:00 をちょうどエポックタイムとして内部表現として`double`（倍精度浮動小数点数）を用いている。Win32では64ビット化された`FILETIME`構造体を使っている。ただし、古い32ビットアプリケーションにおいては、例えWin64のOSで動作しても（WOW64サブシステムでx86 32bit向けのアプリをWin64で動かすシステム）、そのままでは問題解決にならないが、アプリケーションを新しい処理系およびランタイムで構築しなおせば回避はできる。(`time_t`->`__time64_t` 64ビット化される)
